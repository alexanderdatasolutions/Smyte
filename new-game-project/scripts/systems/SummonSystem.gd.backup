# scripts/systems/SummonSystem.gd
extends Node

# SUMMONERS WAR MECHANICS:
# - ALL summoned monsters are kept (no auto-conversion of duplicates)
# - Duplicates are used for:
#   1. Skill-ups (feed same monster to power up skills)
#   2. Evolution materials (use duplicates to evolve monsters)  
#   3. Ancient Crystals (convert max-skilled monsters manually)

const GameDataLoader = preload("res://scripts/systems/DataLoader.gd")

signal summon_completed(god)
signal summon_failed(reason)
signal multi_summon_completed(gods)
signal duplicate_obtained(god, existing_count)

# Configuration data loaded from JSON
var summon_config: Dictionary = {}
var gods_data: Dictionary = {}
var role_data: Dictionary = {}

# Runtime state
var pity_counter = {
	"rare": 0,
	"epic": 0, 
	"legendary": 0
}

var progression_stats = {
	"total_summons": 0,
	"legendary_count": 0,
	"unique_gods": []
}

# Daily/Weekly tracking
var last_free_summon_date = ""
var daily_free_used = false
var last_weekly_premium_date = ""
var weekly_premium_used = false

func _ready():
	load_summon_configuration()
	load_gods_data()
	load_progression_data()

# ==============================================================================
# CONFIGURATION LOADING
# ==============================================================================

func load_summon_configuration():
	"""Load summon configuration from JSON - completely modular"""
	var config_file = FileAccess.open("res://data/summon_config.json", FileAccess.READ)
	if not config_file:
		push_error("Failed to load summon_config.json")
		create_fallback_config()
		return
	
	var json_string = config_file.get_as_text()
	config_file.close()
	
	var json = JSON.new()
	var parse_result = json.parse(json_string)
	if parse_result != OK:
		push_error("Failed to parse summon_config.json")
		create_fallback_config()
		return
	
	summon_config = json.get_data()
	print("SummonSystem: Loaded modular summon configuration")

func load_gods_data():
	"""Load gods data for summon filtering"""
	GameDataLoader.load_all_data()
	gods_data = GameDataLoader.gods_data
	role_data = GameDataLoader.god_roles_data
	print("SummonSystem: Loaded gods data - %d gods available" % gods_data.get("gods", []).size())

func create_fallback_config():
	"""Create minimal fallback configuration"""
	summon_config = {
		"summon_configuration": {
			"costs": {
				"soul_based_summons": {
					"common_soul_summon": { "common_soul": 1 }
				}
			},
			"rates": {
				"soul_based_rates": {
					"common_soul": {
						"common": 70.0,
						"rare": 25.0,
						"epic": 4.5,
						"legendary": 0.5
					}
				}
			}
		}
	}

# ==============================================================================
# MAIN SUMMON FUNCTIONS
# ==============================================================================

# Soul-based summons
func summon_with_soul(soul_type: String) -> bool:
	return _perform_summon(soul_type + "_summon", "soul_based", {"soul_type": soul_type})

func summon_element_soul(element: String) -> bool:
	return _perform_summon(element + "_soul_summon", "element_soul", {"element": element})

# Focused summons
func summon_pantheon_focus(pantheon: String) -> bool:
	return _perform_summon("common_soul_summon", "pantheon_focus", {"pantheon": pantheon})

func summon_role_focus(role: String) -> bool:
	return _perform_summon("common_soul_summon", "role_focus", {"role": role})

# Premium summons
func summon_premium() -> bool:
	return _perform_summon("divine_crystals_summon", "premium")

func summon_with_mana() -> bool:
	return _perform_summon("mana_summon", "mana_based")

# Multi-summons
func multi_summon_soul_pack() -> bool:
	return _perform_multi_summon("soul_pack_10", "soul_pack")

func multi_summon_premium() -> bool:
	return _perform_multi_summon("premium_pack_10", "premium_pack")

func multi_summon_element(element: String) -> bool:
	return _perform_multi_summon("element_pack_10", "element_pack", {"element": element})

func multi_summon_pantheon(pantheon: String) -> bool:
	return _perform_multi_summon("pantheon_pack_10", "pantheon_pack", {"pantheon": pantheon})

func multi_summon_role(role: String) -> bool:
	return _perform_multi_summon("role_pack_10", "role_pack", {"role": role})

# Special summons
func daily_free_summon() -> bool:
	if not can_use_daily_free_summon():
		summon_failed.emit("Daily free summon already used")
		return false
	
	daily_free_used = true
	last_free_summon_date = Time.get_date_string_from_system()
	
	return _perform_summon_with_rates(get_config_rates("soul_based_rates", "common_soul"), "free_daily")

func weekly_premium_summon() -> bool:
	if not can_use_weekly_premium_summon():
		summon_failed.emit("Weekly premium summon already used")
		return false
	
	var discounted_cost = get_config_value("banner_system.special_summons.weekly_premium.discounted_cost", {"divine_crystals": 250})
	if not _can_afford_cost(discounted_cost):
		summon_failed.emit("Cannot afford weekly premium summon")
		return false
	
	_spend_cost(discounted_cost)
	weekly_premium_used = true
	last_weekly_premium_date = Time.get_date_string_from_system()
	
	return _perform_summon_with_rates(get_config_rates("premium_rates", "divine_crystals"), "weekly_premium")

# ==============================================================================
# CORE SUMMON LOGIC
# ==============================================================================

func _perform_summon(cost_type: String, summon_type: String, params: Dictionary = {}) -> bool:
	# Get cost from config
	var cost = get_summon_cost(cost_type)
	if cost.is_empty():
		summon_failed.emit("Invalid summon type: " + cost_type)
		return false
	
	# Check affordability
	if not _can_afford_cost(cost):
		summon_failed.emit("Cannot afford summon cost")
		return false
	
	# Spend resources
	_spend_cost(cost)
	
	# Get appropriate rates
	var rates = get_summon_rates(cost_type, summon_type, params)
	
	# Perform summon
	return _perform_summon_with_rates(rates, summon_type, params)

func _perform_summon_with_rates(rates: Dictionary, summon_type: String, params: Dictionary = {}) -> bool:
	# Apply pity system
	var modified_rates = apply_pity_system(rates)
	
	# Get random god based on rates and filters
	var god_id = get_weighted_random_god(modified_rates, summon_type, params)
	if god_id.is_empty():
		summon_failed.emit("No valid god found")
		return false
	
	# Create god
	var god = _create_god_from_id(god_id)
	if not god:
		summon_failed.emit("Failed to create god")
		return false
	
	# Add to collection (Summoners War style - keep all)
	_add_god_to_collection(god)
	
	# Update progression
	_update_progression_stats(god)
	
	# Update pity counters
	_update_pity_counters(god.get_tier_name().to_lower())
	
	summon_completed.emit(god)
	return true

func _perform_multi_summon(cost_type: String, pack_type: String, params: Dictionary = {}) -> bool:
	var pack_config = get_config_value("summon_configuration.multi_summon_guarantees." + pack_type, {})
	var pack_size = pack_config.get("size", 10)
	
	# Calculate total cost with discount
	var single_cost = get_summon_cost(cost_type.replace("_10", "_summon"))
	var total_cost = {}
	for currency in single_cost:
		total_cost[currency] = single_cost[currency] * (pack_size - 1)  # 10-pull discount
	
	if not _can_afford_cost(total_cost):
		summon_failed.emit("Cannot afford multi-summon")
		return false
	
	_spend_cost(total_cost)
	
	# Perform summons with guarantees
	var summoned_gods = []
	var guarantees = pack_config.get("guarantees", {})
	
	for i in range(pack_size):
		var is_guarantee_summon = should_apply_guarantee(i, pack_size, guarantees)
		var rates = get_summon_rates(cost_type.replace("_10", "_summon"), pack_type, params)
		
		if is_guarantee_summon:
			rates = apply_guarantee_rates(rates, guarantees)
		
		var god_id = get_weighted_random_god(rates, pack_type, params)
		if not god_id.is_empty():
			var god = _create_god_from_id(god_id)
			if god:
				_add_god_to_collection(god)
				_update_progression_stats(god)
				_update_pity_counters(god.get_tier_name().to_lower())
				summoned_gods.append(god)
	
	multi_summon_completed.emit(summoned_gods)
	return summoned_gods.size() > 0

# ==============================================================================
# CONFIGURATION ACCESS HELPERS
# ==============================================================================

func get_summon_cost(cost_type: String) -> Dictionary:
	"""Get summon cost from config"""
	var soul_costs = get_config_value("summon_configuration.costs.soul_based_summons." + cost_type, {})
	if not soul_costs.is_empty():
		return soul_costs
	
	var premium_costs = get_config_value("summon_configuration.costs.premium_summons." + cost_type, {})
	if not premium_costs.is_empty():
		return premium_costs
	
	var multi_costs = get_config_value("summon_configuration.costs.multi_summons." + cost_type, {})
	return multi_costs

func get_summon_rates(cost_type: String, summon_type: String, params: Dictionary) -> Dictionary:
	"""Get summon rates based on type and parameters"""
	var base_rates = {}
	
	# Determine rate source
	if cost_type.ends_with("_soul_summon"):
		var soul_type = cost_type.replace("_summon", "")
		
		# Check if it's element soul
		if soul_type in ["fire_soul", "water_soul", "earth_soul", "lightning_soul", "light_soul", "dark_soul"]:
			base_rates = get_config_rates("element_soul_rates", soul_type)
		else:
			base_rates = get_config_rates("soul_based_rates", soul_type)
	
	elif summon_type == "premium":
		base_rates = get_config_rates("premium_rates", "divine_crystals")
	
	elif summon_type == "mana_based":
		base_rates = get_config_rates("premium_rates", "mana")
	
	else:
		# Default to common soul rates
		base_rates = get_config_rates("soul_based_rates", "common_soul")
	
	return base_rates

func get_config_rates(rate_category: String, rate_type: String) -> Dictionary:
	"""Helper to get rates from config"""
	return get_config_value("summon_configuration.rates." + rate_category + "." + rate_type, {})

func get_config_value(path: String, default_value = null):
	"""Get nested config value using dot notation"""
	var keys = path.split(".")
	var current = summon_config
	
	for key in keys:
		if typeof(current) == TYPE_DICTIONARY and current.has(key):
			current = current[key]
		else:
			return default_value
	
	return current

# ==============================================================================
# GOD SELECTION LOGIC
# ==============================================================================

func get_weighted_random_god(rates: Dictionary, summon_type: String, params: Dictionary) -> String:
	"""Get random god based on rates and filters"""
	# First determine tier
	var tier = get_random_tier_from_rates(rates)
	
	# Get gods matching criteria
	var available_gods = filter_gods_by_criteria(tier, summon_type, params)
	
	if available_gods.is_empty():
		push_warning("No gods found for criteria: tier=%s, type=%s" % [tier, summon_type])
		# Fallback to any god of the tier
		available_gods = get_gods_by_tier(tier)
	
	if available_gods.is_empty():
		return ""
	
	# Apply weighting for special summon types
	var weighted_gods = apply_summon_weights(available_gods, summon_type, params)
	
	# Select random god with weights
	return select_weighted_random_god(weighted_gods)

func get_random_tier_from_rates(rates: Dictionary) -> String:
	"""Randomly select tier based on rates"""
	var random_value = randf() * 100.0
	var cumulative = 0.0
	
	for tier in ["legendary", "epic", "rare", "common"]:
		cumulative += rates.get(tier, 0.0)
		if random_value <= cumulative:
			return tier
	
	return "common"  # Fallback

func filter_gods_by_criteria(tier: String, summon_type: String, params: Dictionary) -> Array:
	"""Filter gods by summon criteria"""
	var all_gods = get_gods_by_tier(tier)
	var filtered_gods = []
	
	for god_config in all_gods:
		if meets_summon_criteria(god_config, summon_type, params):
			filtered_gods.append(god_config)
	
	return filtered_gods

func meets_summon_criteria(god_config: Dictionary, summon_type: String, params: Dictionary) -> bool:
	"""Check if god meets summon criteria"""
	match summon_type:
		"element_soul":
			return god_config.get("element", "") == params.get("element", "")
		
		"pantheon_focus":
			return god_config.get("pantheon", "") == params.get("pantheon", "")
		
		"role_focus":
			var god_roles = get_god_roles(god_config.get("id", ""))
			return params.get("role", "") in god_roles
		
		_:
			return true  # No special criteria

func apply_summon_weights(gods: Array, summon_type: String, params: Dictionary) -> Dictionary:
	"""Apply weighting based on summon focus"""
	var weighted_gods = {}
	var base_weight = 1.0
	
	for god_config in gods:
		var weight = base_weight
		
		# Apply focus weights from config
		match summon_type:
			"element_soul", "element_pack":
				if god_config.get("element", "") == params.get("element", ""):
					weight *= get_config_value("summon_configuration.filtering_weights.element_focus.matching_element_weight", 3.0)
				else:
					weight *= get_config_value("summon_configuration.filtering_weights.element_focus.other_elements_weight", 1.0)
			
			"pantheon_focus", "pantheon_pack":
				if god_config.get("pantheon", "") == params.get("pantheon", ""):
					weight *= get_config_value("summon_configuration.filtering_weights.pantheon_focus.matching_pantheon_weight", 2.5)
				else:
					weight *= get_config_value("summon_configuration.filtering_weights.pantheon_focus.other_pantheons_weight", 1.0)
			
			"role_focus", "role_pack":
				var god_roles = get_god_roles(god_config.get("id", ""))
				if params.get("role", "") in god_roles:
					weight *= get_config_value("summon_configuration.filtering_weights.role_focus.matching_role_weight", 2.0)
				else:
					weight *= get_config_value("summon_configuration.filtering_weights.role_focus.other_roles_weight", 1.0)
		
		weighted_gods[god_config.get("id", "")] = weight
	
	return weighted_gods

func select_weighted_random_god(weighted_gods: Dictionary) -> String:
	"""Select random god from weighted dictionary"""
	if weighted_gods.is_empty():
		return ""
	
	var total_weight = 0.0
	for weight in weighted_gods.values():
		total_weight += weight
	
	var random_value = randf() * total_weight
	var cumulative = 0.0
	
	for god_id in weighted_gods:
		cumulative += weighted_gods[god_id]
		if random_value <= cumulative:
			return god_id
	
	# Fallback
	return weighted_gods.keys()[0]

# ==============================================================================
# PITY SYSTEM
# ==============================================================================

func apply_pity_system(rates: Dictionary) -> Dictionary:
	"""Apply pity system modifications to rates"""
	if not get_config_value("summon_configuration.pity_system.enabled", true):
		return rates
	
	var modified_rates = rates.duplicate()
	var pity_config = get_config_value("summon_configuration.pity_system", {})
	var thresholds = pity_config.get("thresholds", {})
	
	# Hard pity - guarantee at threshold
	if pity_counter.legendary >= thresholds.get("legendary", 100):
		return {"legendary": 100.0, "epic": 0.0, "rare": 0.0, "common": 0.0}
	
	if pity_counter.epic >= thresholds.get("epic", 50):
		return {"legendary": rates.get("legendary", 0.0), "epic": 100.0 - rates.get("legendary", 0.0), "rare": 0.0, "common": 0.0}
	
	# Soft pity - rate increase
	var soft_pity = pity_config.get("soft_pity", {})
	if soft_pity.get("enabled", true):
		apply_soft_pity_rates(modified_rates, soft_pity)
	
	return modified_rates

func apply_soft_pity_rates(rates: Dictionary, soft_pity_config: Dictionary):
	"""Apply soft pity rate increases"""
	var legendary_config = soft_pity_config.get("legendary", {})
	var legendary_start = legendary_config.get("starts_at", 75)
	var legendary_increase = legendary_config.get("rate_increase_per_summon", 0.5)
	
	if pity_counter.legendary >= legendary_start:
		var bonus_rate = (pity_counter.legendary - legendary_start) * legendary_increase
		rates.legendary = min(rates.get("legendary", 0.0) + bonus_rate, 100.0)
	
	var epic_config = soft_pity_config.get("epic", {})
	var epic_start = epic_config.get("starts_at", 35)
	var epic_increase = epic_config.get("rate_increase_per_summon", 1.0)
	
	if pity_counter.epic >= epic_start and pity_counter.legendary < legendary_start:
		var bonus_rate = (pity_counter.epic - epic_start) * epic_increase
		rates.epic = min(rates.get("epic", 0.0) + bonus_rate, 100.0 - rates.get("legendary", 0.0))

func _update_pity_counters(tier: String):
	"""Update pity counters after summon"""
	match tier:
		"legendary":
			pity_counter.legendary = 0
			pity_counter.epic = 0
			pity_counter.rare = 0
		"epic":
			pity_counter.epic = 0
			pity_counter.rare = 0
			pity_counter.legendary += 1
		"rare":
			pity_counter.rare = 0
			pity_counter.legendary += 1
			pity_counter.epic += 1
		"common":
			pity_counter.legendary += 1
			pity_counter.epic += 1
			pity_counter.rare += 1

# ==============================================================================
# UTILITY FUNCTIONS
# ==============================================================================

func get_gods_by_tier(tier: String) -> Array:
	"""Get all gods of specified tier"""
	var tier_gods = []
	for god_config in gods_data.get("gods", []):
		if god_config.get("tier", "").to_lower() == tier.to_lower():
			tier_gods.append(god_config)
	
	return tier_gods

func get_god_roles(god_id: String) -> Array:
	"""Get roles for specific god"""
	if role_data and role_data.has("god_role_assignments") and role_data.god_role_assignments.has(god_id):
		var assignment = role_data.god_role_assignments[god_id]
		var roles = [assignment.get("role", "")]
		
		if assignment.has("secondary_role"):
			roles.append(assignment.secondary_role)
		
		return roles
	
	return ["gatherer"]  # Default role

func _create_god_from_id(god_id: String) -> God:
	"""Create god instance from ID"""
	# This would call your existing God creation system
	return God.create_from_json(god_id)

func _add_god_to_collection(god: God):
	"""Add god to player collection"""
	if not GameManager or not GameManager.player_data:
		return
	
	GameManager.player_data.add_god(god)
	
	# Check for duplicates
	var duplicate_count = 0
	for existing_god in GameManager.player_data.gods:
		if existing_god.id == god.id:
			duplicate_count += 1
	
	if duplicate_count > 1:
		duplicate_obtained.emit(god, duplicate_count - 1)

func _update_progression_stats(god: God):
	"""Update progression tracking"""
	progression_stats.total_summons += 1
	
	if god.get_tier_name().to_lower() == "legendary":
		progression_stats.legendary_count += 1
	
	if not progression_stats.unique_gods.has(god.id):
		progression_stats.unique_gods.append(god.id)
	
	# Check for milestone rewards
	check_progression_milestones()

func check_progression_milestones():
	"""Check and award progression milestone rewards"""
	var milestones = get_config_value("progression_tracking.milestones", {})
	
	for milestone_key in milestones:
		var milestone_count = int(milestone_key.replace("_summons", ""))
		if progression_stats.total_summons == milestone_count:
			var reward = milestones[milestone_key].get("reward", {})
			award_milestone_reward(reward)

func award_milestone_reward(reward: Dictionary):
	"""Award milestone reward to player"""
	if not GameManager or not GameManager.player_data:
		return
	
	for resource_type in reward:
		var amount = reward[resource_type]
		GameManager.player_data.add_resource(resource_type, amount)
	
	print("Milestone reward awarded: ", reward)

# ==============================================================================
# AFFORDABILITY & SPENDING
# ==============================================================================

func _can_afford_cost(cost: Dictionary) -> bool:
	"""Check if player can afford cost"""
	if not GameManager or not GameManager.player_data:
		return false
	
	for currency in cost:
		var required = cost[currency]
		if GameManager.player_data.get_resource(currency) < required:
			return false
	
	return true

func _spend_cost(cost: Dictionary):
	"""Spend resources for summon"""
	if not GameManager or not GameManager.player_data:
		return
	
	for currency in cost:
		var amount = cost[currency]
		GameManager.player_data.spend_resource(currency, amount)

# ==============================================================================
# SPECIAL SUMMON AVAILABILITY
# ==============================================================================

func can_use_daily_free_summon() -> bool:
	var current_date = Time.get_date_string_from_system()
	return last_free_summon_date != current_date

func can_use_weekly_premium_summon() -> bool:
	var current_date = Time.get_date_string_from_system()
	var last_date = Time.get_date_dict_from_string(last_weekly_premium_date) if not last_weekly_premium_date.is_empty() else {}
	var current_date_dict = Time.get_date_dict_from_system()
	
	if last_date.is_empty():
		return true
	
	# Check if a week has passed
	var days_diff = (current_date_dict.day + current_date_dict.month * 30 + current_date_dict.year * 365) - (last_date.day + last_date.month * 30 + last_date.year * 365)
	return days_diff >= 7

# ==============================================================================
# GUARANTEE SYSTEM (Multi-summons)
# ==============================================================================

func should_apply_guarantee(summon_index: int, total_summons: int, guarantees: Dictionary) -> bool:
	"""Check if this summon should have guarantee applied"""
	# Guarantee on last summon if nothing good was summoned
	return summon_index == total_summons - 1

func apply_guarantee_rates(rates: Dictionary, guarantees: Dictionary) -> Dictionary:
	"""Modify rates to apply guarantees"""
	var modified_rates = rates.duplicate()
	
	if guarantees.has("rare_or_better"):
		# Ensure at least rare
		if modified_rates.get("common", 0.0) > 0:
			var common_rate = modified_rates.common
			modified_rates.common = 0.0
			modified_rates.rare = modified_rates.get("rare", 0.0) + common_rate
	
	if guarantees.has("epic_or_better"):
		# Ensure at least epic
		var lower_rates = modified_rates.get("common", 0.0) + modified_rates.get("rare", 0.0)
		modified_rates.common = 0.0
		modified_rates.rare = 0.0
		modified_rates.epic = modified_rates.get("epic", 0.0) + lower_rates
	
	return modified_rates

# ==============================================================================
# SAVE/LOAD PROGRESSION
# ==============================================================================

func load_progression_data():
	"""Load progression data from save file"""
	# This would load from GameManager.player_data or save file
	pass

func save_progression_data():
	"""Save progression data"""
	# This would save to GameManager.player_data or save file
	pass
	"light_soul_summon": { "light_soul": 1 },
	"dark_soul_summon": { "dark_soul": 1 },
	
	# Premium currency summons (higher tier guaranteed)
	"divine_crystals_summon": { "divine_crystals": 100 },
	"mana_summon": { "mana": 10000 },
	
	# Multi-summons
	"soul_pack_10": { "common_soul": 10 },
	"premium_pack_10": { "divine_crystals": 900 }
}

# Multi-summon configurations
const MULTI_SUMMON_SIZES = {
	"soul_pack": 10,
	"premium_pack": 10,
	"element_pack": 10,
	"pantheon_pack": 10,
	"role_pack": 10
}

# Guarantee systems for multi-summons
const MULTI_SUMMON_GUARANTEES = {
	"soul_pack": { "rare_or_better": 1 },
	"premium_pack": { "epic_or_better": 1, "legendary_chance": 0.1 },
	"element_pack": { "rare_or_better": 1, "featured_element": 5 },
	"pantheon_pack": { "rare_or_better": 1, "featured_pantheon": 3 },
	"role_pack": { "rare_or_better": 1, "featured_role": 2 }
}

# Soul-based summon rates based on soul tier
const SOUL_SUMMON_RATES = {
	"common_soul": {
		"common": 70.0,
		"rare": 25.0,
		"epic": 4.5,
		"legendary": 0.5
	},
	"rare_soul": {
		"common": 0.0,
		"rare": 75.0,
		"epic": 22.0,
		"legendary": 3.0
	},
	"epic_soul": {
		"common": 0.0,
		"rare": 0.0,
		"epic": 85.0,
		"legendary": 15.0
	},
	"legendary_soul": {
		"common": 0.0,
		"rare": 0.0,
		"epic": 0.0,
		"legendary": 100.0
	}
}

# Premium currency rates (higher tier bias)
const PREMIUM_SUMMON_RATES = {
	"divine_crystals": {
		"common": 35.0,
		"rare": 40.0,
		"epic": 20.0,
		"legendary": 5.0
	},
	"mana": {
		"common": 50.0,
		"rare": 35.0,
		"epic": 13.0,
		"legendary": 2.0
	}
}

# Current active banners/events
var active_banners = []
var daily_free_summon_used = false
var last_free_summon_date = ""

# Soul-based summon functions
func summon_with_soul(soul_type: String) -> bool:
	return _perform_summon(soul_type + "_summon", "soul_based", {"soul_type": soul_type})

func summon_element_soul(element: String) -> bool:
	return _perform_summon(element + "_soul_summon", "element_soul", {"element": element})

func summon_pantheon_focus(pantheon: String) -> bool:
	return _perform_summon("common_soul_summon", "pantheon_focus", {"pantheon": pantheon})

func summon_role_focus(role: String) -> bool:
	return _perform_summon("common_soul_summon", "role_focus", {"role": role})

func summon_premium() -> bool:
	return _perform_summon("divine_crystals_summon", "premium")

func summon_with_mana() -> bool:
	return _perform_summon("mana_summon", "mana_based")

# Multi-summon functions
func multi_summon_soul_pack() -> bool:
	return _perform_multi_summon("soul_pack_10", "soul_pack")

func multi_summon_premium() -> bool:
	return _perform_multi_summon("premium_pack_10", "premium_pack")

func multi_summon_element(element: String) -> bool:
	return _perform_multi_summon("soul_pack_10", "element_pack", {"element": element})

func multi_summon_pantheon(pantheon: String) -> bool:
	return _perform_multi_summon("soul_pack_10", "pantheon_pack", {"pantheon": pantheon})

func multi_summon_role(role: String) -> bool:
	return _perform_multi_summon("role_pack_10", "role_pack", {"role": role})

# ==============================================================================
# CONFIGURATION ACCESS HELPERS
# ==============================================================================

func get_summon_cost(cost_type: String) -> Dictionary:
	var multi_cost = {}
	var single_cost = SUMMON_COSTS[cost_type]
	var count = MULTI_SUMMON_SIZES[summon_type]
	
	# Calculate multi-summon cost (usually discounted)
	for currency in single_cost.keys():
		multi_cost[currency] = single_cost[currency] * count * 0.9  # 10% discount
	
	# Check affordability
	if not _can_afford_cost(multi_cost):
		summon_failed.emit("Insufficient resources for multi-summon")
		return false
	
	# Spend resources
	_spend_cost(multi_cost)
	
	# Perform multiple summons
	var summoned_gods = []
	var guaranteed_tiers = []
	
	# Apply guarantees
	var guarantees = MULTI_SUMMON_GUARANTEES[summon_type]
	for guarantee_type in guarantees.keys():
		for i in range(guarantees[guarantee_type]):
			guaranteed_tiers.append(guarantee_type)
	
	# Perform summons
	for i in range(count):
		var force_tier = ""
		if i < guaranteed_tiers.size():
			force_tier = guaranteed_tiers[i]
		
		var god_id = _get_random_god_with_pity(summon_type, params, force_tier)
		var god = _create_god_from_id(god_id)
		
		if god:
			# In Summoners War style - ALWAYS keep all summoned gods
			GameManager.player_data.add_god(god)
			summoned_gods.append(god)
			
			# Track duplicates for UI feedback
			var duplicate_count = 0
			for existing in GameManager.player_data.gods:
				if existing.id == god_id:
					duplicate_count += 1
			
			if duplicate_count > 1:
				duplicate_obtained.emit(god, duplicate_count - 1)
	
	multi_summon_completed.emit(summoned_gods)
	# Don't emit individual god_summoned signals for multi-summons
	# The UI handles them via multi_summon_completed signal
	
	return summoned_gods.size() > 0

func _get_element_god_with_pity(element: int) -> String:
	# Get element-specific god first, then apply pity if needed
	var element_god = _get_random_god_by_element(element)
	
	# Check if pity should override the element selection
	if pity_counter["legendary"] >= 100:
		# Force legendary but prefer element if available
		var element_string = GameDataLoader.element_int_to_string(element)
		var element_legendaries = _get_gods_by_element_and_tier(element_string, "legendary")
		if element_legendaries.size() > 0:
			pity_counter["legendary"] = 0
			pity_counter["epic"] = 0
			pity_counter["rare"] = 0
			return element_legendaries[randi() % element_legendaries.size()]
		else:
			# No legendary of this element, get any legendary
			var legendary_gods = GameDataLoader.get_gods_by_tier("legendary")
			if legendary_gods.size() > 0:
				pity_counter["legendary"] = 0
				pity_counter["epic"] = 0
				pity_counter["rare"] = 0
				return legendary_gods[randi() % legendary_gods.size()].id
	
	return element_god

func _get_gods_by_element_and_tier(element_string: String, tier: String) -> Array:
	GameDataLoader.load_all_data()
	var result = []
	for god_config in GameDataLoader.gods_data.gods:
		if god_config.element.to_lower() == element_string.to_lower() and god_config.tier.to_lower() == tier.to_lower():
			result.push_back(god_config.id)
	return result



func _get_premium_god_with_pity() -> String:
	# Check pity system first (same logic but with premium rates when not forced)
	var force_tier = ""
	if pity_counter["legendary"] >= 100:
		force_tier = "legendary"
		pity_counter["legendary"] = 0
		pity_counter["epic"] = 0
		pity_counter["rare"] = 0
	elif pity_counter["epic"] >= 50:
		force_tier = "epic"
		pity_counter["epic"] = 0
		pity_counter["rare"] = 0
		pity_counter["legendary"] += 1
	elif pity_counter["rare"] >= 10:
		force_tier = "rare"
		pity_counter["rare"] = 0
		pity_counter["epic"] += 1
		pity_counter["legendary"] += 1
	
	var god_config
	if force_tier != "":
		# Force a specific tier due to pity
		var tier_gods = GameDataLoader.get_gods_by_tier(force_tier)
		if tier_gods.size() > 0:
			god_config = tier_gods[randi() % tier_gods.size()]
		else:
			god_config = GameDataLoader.get_random_god_by_rarity("premium_summon")
	else:
		# Use premium summon rates from JSON
		god_config = GameDataLoader.get_random_god_by_rarity("premium_summon")
		
		# Update pity counters based on result
		var tier_name = god_config.tier.to_lower()
		match tier_name:
			"rare":
				pity_counter["rare"] = 0
				pity_counter["epic"] += 1
				pity_counter["legendary"] += 1
			"epic":
				pity_counter["rare"] = 0
				pity_counter["epic"] = 0
				pity_counter["legendary"] += 1
			"legendary":
				pity_counter["rare"] = 0
				pity_counter["epic"] = 0
				pity_counter["legendary"] = 0
			_:  # common
				pity_counter["rare"] += 1
				pity_counter["epic"] += 1
				pity_counter["legendary"] += 1
	
	return god_config.id

func _get_random_god_by_tier(tier: int) -> String:
	var god_ids = _get_god_ids_by_tier(tier)
	if god_ids.size() > 0:
		return god_ids[randi() % god_ids.size()]
	return "ares"  # Fallback

func _get_random_god_by_element(element: int) -> String:
	# Convert element int to string
	var element_string = GameDataLoader.element_int_to_string(element)
	
	# Find all gods with this element from JSON data
	GameDataLoader.load_all_data()
	var matching_gods = []
	for god_config in GameDataLoader.gods_data.gods:
		if god_config.element.to_lower() == element_string.to_lower():
			matching_gods.push_back(god_config)
	
	if matching_gods.size() > 0:
		var chosen_god = matching_gods[randi() % matching_gods.size()]
		return chosen_god.id
	
	# Fallback to any god if no matches
	var all_gods = GameDataLoader.gods_data.gods
	if all_gods.size() > 0:
		return all_gods[randi() % all_gods.size()].id
	
	return "ares"  # Final fallback

func _get_god_ids_by_tier(tier: int) -> Array:
	# Convert tier int to string 
	var tier_string = ""
	match tier:
		0:
			tier_string = "common"
		1:
			tier_string = "rare"
		2:
			tier_string = "epic"
		3:
			tier_string = "legendary"
		_:
			tier_string = "common"
	
	# Use JSON data to get gods by tier
	var tier_gods = GameDataLoader.get_gods_by_tier(tier_string)
	var result = []
	for god_config in tier_gods:
		result.push_back(god_config.id)
	
	return result

func _get_god_ids_by_element(element: int) -> Array:
	# Convert element int to string
	var element_string = GameDataLoader.element_int_to_string(element)
	
	# Find gods by element from JSON data
	GameDataLoader.load_all_data()
	var result = []
	for god_config in GameDataLoader.gods_data.gods:
		if god_config.element.to_lower() == element_string.to_lower():
			result.push_back(god_config.id)
	
	return result

func _create_god_from_id(god_id: String):
	# Use the new JSON-based god creation system
	return God.create_from_json(god_id)

func _get_all_god_ids() -> Array:
	# Get all god IDs from JSON data
	GameDataLoader.load_all_data()
	var all_gods = []
	for god_config in GameDataLoader.gods_data.gods:
		all_gods.push_back(god_config.id)
	return all_gods

# Enhanced helper functions for new summon system

func _can_afford_summon(cost_type: String) -> bool:
	var cost = SUMMON_COSTS[cost_type]
	return _can_afford_cost(cost)

func _can_afford_cost(cost: Dictionary) -> bool:
	for currency in cost.keys():
		var required_amount = cost[currency]
		match currency:
			"divine_essence":
				if GameManager.player_data.divine_essence < required_amount:
					return false
			"crystals":
				if GameManager.player_data.premium_crystals < required_amount:
					return false
			"summon_tickets":
				if GameManager.player_data.summon_tickets < required_amount:
					return false
	return true

func _spend_summon_cost(cost_type: String):
	var cost = SUMMON_COSTS[cost_type]
	_spend_cost(cost)

func _spend_cost(cost: Dictionary):
	for currency in cost.keys():
		var amount = cost[currency]
		match currency:
			# Souls
			"common_soul", "rare_soul", "epic_soul", "legendary_soul":
				GameManager.player_data.spend_resource(currency, amount)
			"fire_soul", "water_soul", "earth_soul", "lightning_soul", "light_soul", "dark_soul":
				GameManager.player_data.spend_resource(currency, amount)
			# Premium currencies  
			"divine_crystals":
				GameManager.player_data.spend_resource(currency, amount)
			"mana":
				GameManager.player_data.spend_resource(currency, amount)
			# Legacy support
			"divine_essence":
				GameManager.player_data.spend_divine_essence(amount)
			"crystals":
				GameManager.player_data.spend_crystals(amount)
			"summon_tickets":
				GameManager.player_data.spend_summon_tickets(amount)



# Enhanced pity system with proper tier support
func _get_random_god_with_pity(summon_type: String = "basic", params: Dictionary = {}, force_tier: String = "") -> String:
	# Handle forced tier (for multi-summon guarantees)
	if force_tier != "":
		return _get_god_by_force_tier(force_tier, summon_type, params)
	
	# Check pity system
	var pity_tier = _check_pity_triggers()
	if pity_tier != "":
		_reset_pity_for_tier(pity_tier)
		return _get_god_by_force_tier(pity_tier, summon_type, params)
	
	# Normal summon with rate ups
	var god_config = _get_weighted_random_god(summon_type, params)
	
	# Update pity counters
	_update_pity_counters(god_config.tier)
	
	return god_config.id

func _check_pity_triggers() -> String:
	if pity_counter["legendary"] >= PITY_THRESHOLDS["legendary"]:
		return "legendary"
	elif pity_counter["epic"] >= PITY_THRESHOLDS["epic"]:
		return "epic"
	elif pity_counter["rare"] >= PITY_THRESHOLDS["rare"]:
		return "rare"
	return ""

func _reset_pity_for_tier(tier: String):
	match tier:
		"legendary":
			pity_counter["legendary"] = 0
			pity_counter["epic"] = 0
			pity_counter["rare"] = 0
		"epic":
			pity_counter["epic"] = 0
			pity_counter["rare"] = 0
			pity_counter["legendary"] += 1
		"rare":
			pity_counter["rare"] = 0
			pity_counter["epic"] += 1
			pity_counter["legendary"] += 1

func _update_pity_counters(tier_name: String):
	match tier_name.to_lower():
		"legendary":
			pity_counter["legendary"] = 0
			pity_counter["epic"] = 0
			pity_counter["rare"] = 0
		"epic":
			pity_counter["epic"] = 0
			pity_counter["rare"] = 0
			pity_counter["legendary"] += 1
		"rare":
			pity_counter["rare"] = 0
			pity_counter["epic"] += 1
			pity_counter["legendary"] += 1
		"common":
			pity_counter["rare"] += 1
			pity_counter["epic"] += 1
			pity_counter["legendary"] += 1

func _get_god_by_force_tier(tier: String, summon_type: String, params: Dictionary) -> String:
	# For element summons, try to get god of specified element first
	if summon_type == "element" and params.has("element"):
		var element_gods = _get_gods_by_element_and_tier(GameDataLoader.element_int_to_string(params.element), tier)
		if element_gods.size() > 0:
			return element_gods[randi() % element_gods.size()]
	
	# Fallback to any god of the tier
	var tier_gods = GameDataLoader.get_gods_by_tier(tier)
	if tier_gods.size() > 0:
		return tier_gods[randi() % tier_gods.size()].id
	
	# Final fallback
	return "ares"

func _get_weighted_random_god(summon_type: String, params: Dictionary) -> Dictionary:
	# Use existing JSON-based random selection but with potential element filtering
	if summon_type == "element" and params.has("element"):
		# For element summons, use modified rates favoring the chosen element
		return _get_element_weighted_god(params.element)
	else:
		# Use standard rates from JSON
		var rates_key = summon_type + "_summon" if summon_type != "basic" else "basic_summon"
		return GameDataLoader.get_random_god_by_rarity(rates_key)

func _get_element_weighted_god(element: int) -> Dictionary:
	# Get element-specific weighted selection
	var element_string = GameDataLoader.element_int_to_string(element)
	GameDataLoader.load_all_data()
	
	# Build weighted list favoring the chosen element
	var weighted_gods = []
	var _total_weight = 0
	
	for god_config in GameDataLoader.gods_data.gods:
		var weight = god_config.get("summon_weight", 1)
		# Double weight for matching element
		if god_config.element.to_lower() == element_string.to_lower():
			weight *= 2
		
		for i in range(weight):
			weighted_gods.append(god_config)
		_total_weight += weight
	
	if weighted_gods.size() > 0:
		return weighted_gods[randi() % weighted_gods.size()]
	
	# Fallback
	return GameDataLoader.get_random_god_by_rarity("basic_summon")

# Daily free summon system
func daily_free_summon() -> bool:
	var current_date = Time.get_date_string_from_system()
	
	if last_free_summon_date == current_date:
		summon_failed.emit("Daily free summon already used")
		return false
	
	last_free_summon_date = current_date
	daily_free_summon_used = true
	
	# Perform free summon (basic rates)
	return _perform_summon_with_free_override("basic_summon", "basic", {}, true)

func _perform_summon_with_free_override(cost_type: String, summon_type: String, params: Dictionary = {}, is_free: bool = false) -> bool:
	# Modified version that can skip cost checking for free summons
	if not is_free:
		if not _can_afford_summon(cost_type):
			summon_failed.emit("Insufficient resources")
			return false
		_spend_summon_cost(cost_type)
	
	var god_id = _get_random_god_with_pity(summon_type, params)
	var god = _create_god_from_id(god_id)
	
	if god:
		# In Summoners War style - ALWAYS keep the summoned god
		GameManager.player_data.add_god(god)
		
		# Track duplicates for UI feedback
		var duplicate_count = 0
		for existing in GameManager.player_data.gods:
			if existing.id == god_id:
				duplicate_count += 1
		
		if duplicate_count > 1:
			duplicate_obtained.emit(god, duplicate_count - 1)
		
		summon_completed.emit(god)
		GameManager.god_summoned.emit(god)
		return true
	
	summon_failed.emit("Failed to create god")
	return false

# Banner/Event system foundation
func activate_banner(banner_config: Dictionary):
	active_banners.append(banner_config)
	print("Activated banner: ", banner_config.get("name", "Unknown Banner"))

func deactivate_banner(banner_id: String):
	for i in range(active_banners.size() - 1, -1, -1):
		if active_banners[i].get("id", "") == banner_id:
			active_banners.remove_at(i)
			print("Deactivated banner: ", banner_id)

func get_active_banners() -> Array:
	return active_banners

func can_use_daily_free_summon() -> bool:
	var current_date = Time.get_date_string_from_system()
	return last_free_summon_date != current_date

# Enhanced banner-based summoning
func summon_from_banner(banner_id: String, count: int = 1) -> bool:
	var banner = GameDataLoader.get_banner_by_id(banner_id)
	if banner.is_empty():
		summon_failed.emit("Banner not found: " + banner_id)
		return false
	
	# Check banner costs
	var costs = banner.get("costs", {})
	var cost_key = "ten_pull" if count == 10 else "single"
	var required_cost = costs.get(cost_key, {})
	
	if not _can_afford_cost(required_cost):
		summon_failed.emit("Cannot afford banner summon")
		return false
	
	# Spend the cost
	_spend_cost(required_cost)
	
	# Perform the summons with banner modifiers
	var summoned_gods = []
	for i in range(count):
		var god_id = _get_banner_modified_god(banner_id, banner)
		var god = _create_god_from_id(god_id)
		
		if god:
			# In Summoners War style - ALWAYS keep all summoned gods
			GameManager.player_data.add_god(god)
			summoned_gods.append(god)
			
			# Track duplicates for UI feedback
			var duplicate_count = 0
			for existing in GameManager.player_data.gods:
				if existing.id == god_id:
					duplicate_count += 1
			
			if duplicate_count > 1:
				duplicate_obtained.emit(god, duplicate_count - 1)
	
	# Emit appropriate signals
	if count == 1:
		if summoned_gods.size() > 0:
			summon_completed.emit(summoned_gods[0])
			GameManager.god_summoned.emit(summoned_gods[0])
	else:
		multi_summon_completed.emit(summoned_gods)
		for god in summoned_gods:
			GameManager.god_summoned.emit(god)
	
	return summoned_gods.size() > 0

func _get_banner_modified_god(_banner_id: String, banner: Dictionary) -> String:
	var featured_gods = banner.get("featured_gods", [])
	var rate_up = banner.get("rate_up", {})
	
	# If this is a featured banner with specific gods
	if featured_gods.size() > 0 and rate_up.has("featured_multiplier"):
		# Chance to get a featured god (enhanced rate)
		var featured_multiplier = rate_up.get("featured_multiplier", 1.0)
		var featured_chance = 0.3 * featured_multiplier  # Base 30% chance for featured, multiplied
		
		if randf() <= featured_chance:
			# Select from featured gods using normal tier rates
			var weighted_featured_gods = []
			for god_id in featured_gods:
				var god_config = GameDataLoader.get_god_config(god_id)
				if not god_config.is_empty():
					var weight = god_config.get("summon_weight", 1)
					for i in range(weight):
						weighted_featured_gods.append(god_config)
			
			if weighted_featured_gods.size() > 0:
				var selected = weighted_featured_gods[randi() % weighted_featured_gods.size()]
				return selected.id
	
	# Use normal summon logic with potential rate modifications
	var summon_type = "basic"  # Default fallback
	if banner.get("type") == "premium":
		summon_type = "premium"
	
	return _get_random_god_with_pity(summon_type)

# Progression tracking
func track_summon_progression(_god: God):
	# Track summons for milestone rewards
	GameManager.player_data.total_summons += 1
	
	# Check for milestone rewards
	var milestones = GameDataLoader.get_summon_milestones()
	var total = GameManager.player_data.total_summons
	
	for milestone_key in milestones.keys():
		var milestone_count = int(milestone_key.split("_")[0])
		if total == milestone_count:
			_award_milestone_reward(milestones[milestone_key])

func _award_milestone_reward(reward_config: Dictionary):
	var reward = reward_config.get("reward", {})
	
	for currency in reward.keys():
		var amount = reward[currency]
		match currency:
			"divine_essence":
				GameManager.player_data.add_divine_essence(amount)
			"crystals":
				GameManager.player_data.add_premium_crystals(amount)
			"summon_tickets":
				GameManager.player_data.add_summon_tickets(amount)
			"ascension_materials":
				GameManager.player_data.add_ascension_materials(amount)
			"guaranteed_epic":
				# Queue a guaranteed epic summon
				pass
			"guaranteed_legendary":
				# Queue a guaranteed legendary summon
				pass
	
	print("Milestone reward awarded: ", reward)
